/*

(a) IntP p0 (ix);       // 不合法，unique_ptr只能绑定到new返回的指针上

(b) IntP p1 (pi);       // 编译时无报错，在我的编译器上也可以正确运行。但不建议使用，
因为使用智能指针unique_ptr，在检测到指针超出范围时，编译器会调用delete去释放，但pi不是又new分配的，
因此就不能使用delete去释放，所以当p1非法时，就会由操作系统抛出错误，造成运行时错误

(c) IntP p2 (pi2);      // 可以使用，但有可能在运行时产生空悬指针pi2，因为运行时，p2所指空间可能被释放，pi2就成为了空悬指针

(d) IntP p3 (&ix);      // 同b，编译器不会报错，但无法使用delete释放

(e) IntP p4 (new int(2048));    // 合法，推荐使用

(f) IntP p5 (p2.get());         // 不合法，使用get初始化一个智能指针，p2和p5指向同一块内存，当指针非法，
智能指针会自动delete，此时这块内存会被二次delete。

*/