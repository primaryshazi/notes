# 语言特性

---

## 引用

### 左值引用 右值引用

- 左值引用：指表达式结束后依然存在的持久对象
- 右值引用：表达式结束就不再存在的临时对象

### 区别

- 左值引用不能绑定到要转换的表达式、字面常量或返回右值的表达式。右值引用恰好相反，可以绑定到这类表达式，但不能绑定到一个左值上
- 右值引用必须绑定到右值的引用，通过 && 获得。右值引用只能绑定到一个将要销毁的对象上，因此可以自由地移动其资源
- 左值可以使用 & 获取对象地址。右值不可以

### std::move

std::move 可以将一个左值强制转化为右值，继而可以通过右值引用使用该值，以用于移动语义，进行所有权转移

---

## pointer reference

### 初始化

``` cpp
int i = 0;

/**
 * 指针在初始化时可以指向一个变量，也可以不指向空
 * 引用在初始化时必须引用一个左值，引用不可引用空
 */
int *p1 = &i;
int *p2;

int &r = i;
```

### 大小

``` cpp
std::string str = 0;

std::string *p = &str;
std::string *r = str;

/**
 * 8
 * 32
 * 指针一个真实的实体，是指针本身的大小
 * 引用是变量的别名无实体，与变量的大小一致
 */
sizeof(p);
sizeof(r);
```

### 传递参数

``` cpp
#include <iostream>

void PassByPointer(const char *str)
{
    printf("%p    %p\n", str, &str);
}

void PassByPointerRef(const char *&str)
{
    printf("%p    %p\n", str, &str);
}

int main()
{
    const char *str = "Hello World!";

    /**
     * => 000000000040900e    000000000063fe18
     * => 000000000040900e    000000000063fdf0
     * => 000000000040900e    000000000063fe18
     */
    printf("%p    %p\n", str, &str);
    PassByPointer(str);         // 传递指针，是对指针的拷贝，两个指针指向相同的地址
    PassByPointerRef(str);      // 传递指针的引用，是对指针的别名，实际上是同一个指针

    return 0;
}
```

### 更改指向

**已经初始化过的指针可以指向其他对象**
**已经初始化过的引用不可引用其他对象**

---

## 类型转换

### static_cast

- 用于基本数据类型的转换
- 用于上行转换，下行转换不安全
- 可以将空指针转化成目标类型的空指针
- 可以将任何类型的表达式转化成 void 类型

### const_cast

强制去掉常量属性，不能用于去掉变量的常量性，只能用于去除指针或引用的常量性

### reinterpret_cast

改变指针或引用的类型、将指针或引用转换为一个足够长度的整型、将整型转化为指针或引用类型

### dynamic_cast

只能用于带有虚函数的基类或派生类的指针或者引用对象的转换，上行转换与static_cast相同，下行转换失败返回空指针

---

## 智能指针与指针

1. 不要用一个裸指针初始化多个shared_ptr，会出现double_free导致程序崩溃
2. 通过shared_from_this()返回this指针，不要把this指针作为shared_ptr返回出来，因为this指针本质就是裸指针，通过this返回可能 会导致重复析构，不能把this指针交给智能指针管理
3. 不要delete get()返回来的裸指针
4. 不是new出来的空间要自定义删除器
5. 要避免循环引用，循环引用导致内存永远不会被释放，造成内存泄漏

## 智能指针管理数组

``` cpp

class A
{
public:
    A() { std::cout << __FUNCTION__ << std::endl; }
    ~A() { std::cout << __FUNCTION__ << std::endl; }
};

std::shared_ptr<A> sp(new A[5], [](A *a) { delete[] a; });
std::unique_ptr<A[]> up = std::make_unique<A[]>(5);

```

---

## 指针和数组

1. 数组一旦声明，我们就不能再给它赋值，但是我们可以给指针赋值
2. 用指针定义字符串时，指针所指的字符串会被理解为常量字符串，不能修改。数组定义的字符串则可以修改
3. 用sizeof运算符可以计算数组变量的数组大小，但指针指向数组时，只能计算出指针本身大小

---

## switch和case中声明变量

C++的一条规则：在任何作用域内，假如存在变量初始化语句，该初始化语句不可以被跳过，一定要执行！。而case中有可能会被跳过的情况。可以在生命在case之前或者采用`{ }`括起代码块

---
