# 类

---

## 类自动生成函数

``` cpp
class Empty
{
public:
    Empty();                            //缺省构造函数
    Empty(const Empty &rhs);            //拷贝构造函数
    ~Empty();                           //析构函数
    Empty &operator=(const Empty &rhs); //赋值运算符
    Empty *operator&();                 //取址运算符
    const Empty *operator&() const;     //取址运算符(const版本)
};
```

---

## 默认生成

### 构造函数

- 含有类对象数据成员，该类对象类型有默认构造函数
- 基类带有默认构造函数的派生类
- 类中存在虚函数
- 存在虚基类

---

## 初始化

- 成员变量在使用初始化列表初始化时，与构造函数中初始化成员列表的顺序无关，只与定义成员变量的顺序有关
- 类中const成员常量必须在构造函数初始化列表中初始化
- 类中static成员变量，只能在类内外初始化

### 初始化顺序

1. 基类的静态变量或全局变量
2. 派生类的静态变量或全局变量
3. 基类的成员变量
4. 派生类的成员变量

---

## 对象构造顺序

1. 编译器计算类大小，分配内存空间
2. 初始化列表，初始化成员变量
3. 调用构造函数

---

## 虚函数

虚函数通过虚函数表来实现。虚函数的地址保存在虚函数表中，在类的对象所在的内存空间中，保存了指向虚函数表的指针（虚表指针），通过虚表指针可以找到类对应的虚函数表。虚函数表解决了基类和派生类的继承问题和类中成员函数的覆盖问题，当用基类的指针来操作一个派生类的时候，这张虚函数表就指明了实际应该调用的函数

### 虚函数表存放内容

类的虚函数的地址

### 虚函数表建立的时间

编译阶段，即程序的编译过程中会将虚函数的地址放在虚函数表中

### 虚表指针保存的位置

虚表指针存放在对象的内存空间中最前面的位置，这是为了保证正确取到虚函数的偏移量

### 虚表绑定关系

虚函数表和类绑定，虚表指针和对象绑定。即类的不同的对象的虚函数表是一样的，但是每个对象都有自己的虚表指针，来指向类的虚函数表

### 构造函数与虚函数

构造函数不能定义为虚函数

- 在创建对象时需要明确其类型
- 虚函数表是在创建对象之后才有的，因此不能定义成虚函数
- 虚函数是基类的指针指向派生类的对象时，通过该指针实现对派生类的虚函数的调用，构造函数是在创建对象时自动调用的

### 析构函数与虚函数

析构函数一般定义为虚函数

- 析构函数定义成虚函数是为了防止内存泄漏，因为当基类的指针或者引用指向或绑定到派生类的对象时，如果未将基类的析构函数定义成虚函数，会调用基类的析构函数，那么只能将基类的成员所占的空间释放掉，派生类中特有的就会无法释放内存空间导致内存泄漏

### 内联函数与虚函数

虚函数可以定义为内联函数。内联函数调用在编译期确定，虚函数调用在运行期确定。由于内联函数只是一个申请而非强制所以具体是否要内联取决于如何调用函数

---

## 不可拷贝类

### delete

``` cpp
class A
{
public:
    A(const A &) = delete;
    A &operator=(const A &) = delete;
};
```

### 基类私有继承

``` cpp
class Uncopyable
{
public:
    Uncopyable() {}
    ~Uncopyable() {}

private:
    Uncopyable(const Uncopyable &);            // 拷贝构造函数
    Uncopyable &operator=(const Uncopyable &); // 赋值构造函数
};

// 在拷贝A时需要调用Uncopyable的拷贝函数，Uncopyable不可访问，故不可拷贝
class A : private Uncopyable // 私有继承
{
};

```

---

## 不可继承类

### final

``` cpp
class Finally final
{
};
```

### 友元类

``` cpp
template <typename T>
class Base
{
    friend T;

private:
    Base() {}
    ~Base() {}
};

// 只有Finally可以调用基类的构造函数
class Finally : virtual public Base<Finally>    //一定注意 必须是虚继承
{
};

```

---

## 深浅拷贝

如果一个类拥有资源，该类的对象进行复制时，如果资源重新分配，就是深拷贝，否则就是浅拷贝

### 区别

- 深拷贝：该对象和原对象占用不同的内存空间，既拷贝存储在栈空间中的内容，又拷贝存储在堆空间中的内容
- 浅拷贝：该对象和原对象占用同一块内存空间，仅拷贝类中位于栈空间中的内容

### 适用

当类的成员变量中有指针变量时，最好使用深拷贝。因为当两个对象指向同一块内存空间，如果使用浅拷贝，当其中一个对象的删除后，该块内存空间就会被释放，另外一个对象指向的就是垃圾内存

---
