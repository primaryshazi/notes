# 协程

---

## 切换

协程运行在线程之上，当一个协程执行完成后，可以选择主动让出，让另一个协程运行在当前线程之上。协程并没有增加线程数量，只是在线程的基础之上通过分时复用的方式运行多个协程，而且协程的切换在用户态完成，切换的代价比线程从用户态到内核态的代价小很多

---

## 注意

- 不可使协程运行在阻塞线程上
    协程运行在线程之上，并且协程调用了一个阻塞IO操作，这时候会发生什么？实际上操作系统并不知道协程的存在，它只知道线程，因此在协程调用阻塞IO操作的时候，操作系统会让线程进入阻塞状态，当前的协程和其它绑定在该线程之上的协程都会陷入阻塞而得不到调度
- 协程应该配合异步IO操作方能得到最大效率

---

## 对称和非对称

- 对称：协程启动之后与启动之前没有任何关系，协程的切换交由yield调度
- 非对称：协程启动之后，让出CPU后只能将控制权交由调用它的协程

---

## 协程切换

- 在切换的时候，寄存器需要保存和加载的数据量比较小
- 高速缓存可以有效利用
- 没有用户模式到内核模式的切换操作
- 更有效率的调度，因为协程是非抢占式的，前一个协程执行完毕或者堵塞，才会让出CPU，而线程则一般使用了时间片的算法，会进行很多没有必要的切换

---
