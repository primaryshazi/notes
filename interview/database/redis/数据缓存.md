# 数据缓存

## 缓存数据库一致性

### 先删除缓存再更新数据库

进行更新操作时，先删除缓存，然后更新数据库，后续的请求再次读取时，会从数据库读取后再将新数据更新到缓存。删除缓存和更新数据库之间，若有请求则会将数据库中的旧数据再次同步到缓存，后续请求的都是旧数据

### 先更新数据库再删除缓存

进行更新操作时，先更新数据库，成功之后删除缓存，后续读取请求时再将新数据回写缓存。在更新数据库和删除缓存之间，若有请求则读取的还是换成你中的旧数据，在删除缓存之后就会正常

### 异步更新缓存

数据库的更新操作完成后不直接操作缓存，而是把这个操作命令封装成消息扔到消息队列中，然后由Redis自己去消费更新数据，消息队列可以保证数据操作顺序一致性，确保缓存系统的数据正常

## 缓存穿透

缓存穿透是指查询一个不存在的数据，由于缓存是不命中时被动写的，如果从DB查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到DB去查询，失去了缓存的意义。在流量大时，可能数据库就挂掉了。1.缓存空值，不会查数据库。2.采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的bitmap中，查询不存在的数据会被这个bitmap拦截掉，从而避免了对数据库的查询压力

## 缓存雪崩

缓存雪崩是指在我们设置缓存时采用了相同的过期时间，导致缓存在某一时刻同时失效，请求全部转发到数据库，数据库瞬时压力过重挂掉。在原有的失效时间基础上增加一个随机值，使得过期时间分散一些

## 缓存击穿

大量的请求同时查询一个key时，此时这个key正好失效了，就会导致大量的请求都落到数据库。加分布式锁，第一个请求的线程可以拿到锁，拿到锁的线程查询到了数据之后设置缓存，其他的线程获取锁失败会等待50ms然后重新到缓存取数据，这样便可以避免大量的请求落到数据库
