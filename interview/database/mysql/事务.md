# 事务

## 什么是事务

事务就是为了保证一组数据库操作，要么全部成功，要么全部失败

## 事务四大特征(ACID)

- 原子性
    事务是最小单位，不可再分
- 一致性
    事务要求所有的DML语句操作的时候，必须保证同时成功或者同时失败
- 隔离性
    事务A和事务B之间具有隔离性
- 持久性
    事务一旦提交，它对数据库的改变应该是永久的

## 脏读，幻读，不可重复读

- 脏读
    前者事务未提交，后者事务读取，然后前者回滚，后者事务读取数据不正确
- 幻读
    前者事务第一次读取之后，后者事务插入数据，前者再次读取则会读到几条之前不存在的数据
- 不可重复读
    在两次读取之中，进行的一次数据更新事务，导致前后两个数据不一致

## 事务隔离级别

- READ UNCOMMITTED
    读未提交：允许某个事务看到其他事务尚未提交的行修改
- READ COMMITTED
    读已提交：允许某个事务看到其他事务已经提交的行修改
- REPRATABLE READ
    可重复读：某个事务指定两个相同的查询语句，其结果是一致的
- SERIALIZABLE
    串行化：在一个事务进行读取时，其他事务不得对这些行进行修改

## 事务隔离级别与相应问题

隔离级别|脏读|不可重复读|幻读
-|-|-|-
READ UNCOMMITTED|是|是|是
READ COMMITTED|否|是|是
REPRATABLE READ|否|否|是
SERIALIZABLE|否|否|否

## 事务隔离级别与锁的关系

- 读未提交
    读数据不需要加共享锁
- 读已提交
    读数据需要共享锁，读完之后即释放
- 可重复读
    读数据需要共享锁，事务体提交之后释放
- 串行化
    对读取的整个范围进行加锁，事务提交之后释放

## 数据库按照粒度分有那几种锁

- 表级锁
    表示对当前操作的整张表加锁，它实现简单，资源消耗较少，表级锁定分为表分为共享锁和排他锁
- 行级锁
    表示只针对当前操作的行进行加锁。行级锁能大大减少数据库操作的冲突。其加锁粒度最小，但加锁的开销也最大。行级锁分为共享锁和排他锁
- 页级锁
    页级锁是MySQL中锁定粒度介于行级锁和表级锁中间的一种锁，一次锁定相邻的一组记录

## 什么是共享锁和排他锁

- 共享锁（读锁）
    当用户要进行数据的读取时，对数据加上共享锁。共享锁可以同时加上多个
- 排他锁（写锁）
    当用户要进行数据的写入时，对数据加上排他锁。排他锁只可以加一个，他和其他的排他锁，共享锁都相斥

## 什么是悲观锁和乐观锁

- 悲观锁
    总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁。如行锁，表锁等，读锁，写锁等
- 乐观锁
    总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据

## 如何处理死锁

- 如果不同程序会并发存取多个表，尽量约定以相同的顺序访问表，可以大大降低死锁机会
- 在同一个事务中，尽可能做到一次锁定所需要的所有资源，减少死锁产生概率
- 对于非常容易产生死锁的业务部分，可以尝试使用升级锁定颗粒度，通过表级锁定来减少死锁产生的概率
